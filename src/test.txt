if (init_delimiter ()) {
        if (init_stop_words ()) {
            string ** documents = NULL;
            string * file_names = NULL;

            unsigned int size = 0;
            unsigned int * document_size = NULL;

            do {file_names = (string *) malloc (sizeof (string) * 10);} while (file_names == NULL);
            file_names [0] = "txt/1.txt";
            file_names [1] = "txt/2.txt";
            file_names [2] = "txt/3.txt";
            file_names [3] = "txt/4.txt";
            file_names [4] = "txt/5.txt";
            file_names [5] = "txt/6.txt";
            file_names [6] = "txt/7.txt";
            file_names [7] = "txt/8.txt";
            file_names [8] = "txt/9.txt";
            file_names [9] = "txt/10.txt";
            // file_names [10] = "txt/11.txt";
            // file_names [11] = "txt/12.txt";
            // file_names [12] = "txt/13.txt";
            // file_names [13] = "txt/14.txt";
            // file_names [14] = "txt/15.txt";

            if ((size = get_input_from_files (file_names, &documents, 10, &document_size)) != 0) {
                free (file_names);
                file_names = NULL;
                printf ("Reading From File Is A Success:\n\n");

                if (lower_all (&documents, &size, document_size)) {
                    for (unsigned int counter = 0; counter < size; ++counter) {
                        printf ("The data in the document [%u] are:\n", (counter + 1));
                        for (unsigned int inside = 0; inside < document_size [counter]; printf ("\tThe data in line [%u] is: %s.\n", (inside + 1), documents [counter][inside]), ++inside);
                        printf ("\n");
                    }

                    void **** content = tokenize (&documents, &size, document_size);

                    if (content == NULL)
                        printf ("NO!!!\n\n");
                    else {
                        string ** doc_tokens = ((string **) content [0]);
                        unsigned int * doc_tokens_size = ((unsigned int *) content [1][0][0]);
                        
                        content [0] = NULL;
                        content [1][0][0] = NULL;
                        free (content [1][0]);
                        content [1][0] = NULL;
                        free (content [1]);
                        content [1] = NULL;

                        for (unsigned int counter = 0; counter < size; ++counter)
                            for (unsigned int inside = 0; inside < doc_tokens_size [counter]; ++inside)
                                printf ("The token in document #[%u] is: %s.\n", (counter + 1), doc_tokens [counter][inside]);

                        unsigned int largest_length = largest_token_term ((void *) doc_tokens, &size, doc_tokens_size);
                        printf ("\nThe largest length in the docs token is of value: %u.\n", largest_length);

                        solve_hyphen_problems (&doc_tokens, &size, doc_tokens_size);

                        if (sort_term_token_1 (&doc_tokens, &size, doc_tokens_size)) {
                            printf ("\nDocument's tokens after sorting\n");
                            print_doc_tokens (&doc_tokens, &size, doc_tokens_size, &largest_length);
                            printf ("\n");
                        }

                        printf ("\n");

                        // if (remove_repeated_term_token_1 (&doc_tokens, &size, doc_tokens_size)) {
                        //     printf ("Document After Removeing Duplicates In Each Document\n");
                        //     print_doc_tokens (&doc_tokens, &size, doc_tokens_size, &largest_length);
                        //     printf ("\n");
                        //     for (unsigned int counter = 0; counter < size; printf ("this n tokens is this doc is: %u\n", doc_tokens_size [counter]), ++counter);
                        //     printf ("\n");
                        // }

                        // printf ("\n");
                        
                        printf ("\nConverting the token list from token list per docuemnt to token list.\n");
                        printf ("\tBuild the meta\n");

                        unsigned int * meta = NULL;
                        do {meta = (unsigned int *) malloc (sizeof (unsigned int) * (size + 2));} while (meta == NULL);
                        meta [0] = 0;
                        meta [1] = size;
                        for (unsigned int counter = 0; counter < size; meta [0] += doc_tokens_size [counter], meta [(2 + counter)] = doc_tokens_size [counter], ++counter);
                        printf ("\tMeta is built\n");

                        string * tokens = degrade_list_2 (&doc_tokens, meta);

                        if (tokens == NULL) {
                            printf ("NO!!\n\n");
                        } else {
                            printf ("\nThe tokens are:\n");
                            for (unsigned int counter = 0; counter < meta [0]; printf ("\tToken #[%u] is: %s.\n", (counter + 1), tokens [counter]), ++counter);
                            printf ("\n");
                        }

                        if (remove_repeated_term_token_2 (&tokens, &meta [0])) {
                            printf ("The tokens list after removing duplicates\n");
                            for (unsigned int counter = 0; counter < meta [0]; printf ("\tToken #[%u] Is: %s.\n", (counter + 1), tokens [counter]), ++counter);
                            printf ("\n");
                        }

                        largest_length = largest_token_term ((void *) tokens, &meta [0], NULL);
                        printf ("\nThe largest length in the token list is of value: %u.\n\n", largest_length);

                        for (unsigned int counter = 0; counter < (meta [0] - 1); ++counter)
                            printf ("Comparing: %s And %s: %d.\n", tokens [counter], tokens [(counter + 1)], which_is_bigger (&tokens [counter], &tokens [(counter + 1)]));

                        if (sort_term_token_2 (&tokens, &meta [0])) {
                            printf ("\nData After Sorting:\n");
                            for (unsigned int counter = 0; counter < meta [0]; printf ("\tToken #[%u] is: %s.\n", (counter + 1), tokens [counter]), ++counter);
                        }

                        printf ("\n");

                        print_tokens (&tokens, &meta [0], &largest_length, NULL, 1);

                        unsigned int mps_size = get_mps_size (&doc_tokens, &size, doc_tokens_size);

                        if (meta [0] == mps_size)
                            printf ("\nYes: %u\t%u\n", meta [0], mps_size);

                        printf ("\n");

                        unsigned int *** inc_mat = build_incidence_matrix (&doc_tokens, &size, doc_tokens_size);
                        if (inc_mat != NULL) {
                            printf ("\n\n");
                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                printf ("The #%u doc_frequency for term: %s is: %u and its term_frequency is: %u.\n", (counter + 1), tokens [counter], inc_mat [0][0][counter], inc_mat [1][0][counter]);

                            }
                            printf ("\n\n");
                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                printf ("The document vector for term %s is:\n\t", tokens [counter]);
                                for (unsigned int inside = 0; inside < size; ++inside)
                                    printf ("%u  ", inc_mat [2][counter][inside]);
                                printf ("\n");
                            }

                            free (inc_mat [0][0]);
                            inc_mat [0][0] = NULL;
                            free (inc_mat [0]);
                            inc_mat [0] = NULL;
                            free (inc_mat [1][0]);
                            inc_mat [1][0] = NULL;
                            free (inc_mat [1]);
                            inc_mat [1] = NULL;
                            for (unsigned int counter = 0; counter < mps_size; free (inc_mat [2][counter]), inc_mat [2][counter] = NULL, ++counter);
                            free (inc_mat [2]);
                            inc_mat [2] = NULL;
                            free (inc_mat);
                            inc_mat = NULL;
                        }

                        inc_mat = build_inverted_index (&doc_tokens, &size, doc_tokens_size);
                        if (inc_mat != NULL) {
                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                printf ("The term is: %s. Its docFreq is: %u. Its terFreq is: %u.\n", tokens [counter], inc_mat [0][0][counter], inc_mat [1][0][counter]);
                                printf ("The posting of that term is:\n\t");
                                for (unsigned int inside = 0; inside < inc_mat [0][0][counter]; ++inside)
                                    printf ("%u  ", inc_mat [2][counter][inside]);
                                
                                printf ("\n");
                                free (inc_mat [2][counter]);
                                inc_mat [2][counter] = NULL;
                            }

                            free (inc_mat [2]);
                            inc_mat [2] = NULL;
                            free (inc_mat [0][0]);
                            inc_mat [0][0] = NULL;
                            free (inc_mat [0]);
                            inc_mat [0] = NULL;
                            free (inc_mat [1][0]);
                            inc_mat [1][0] = NULL;
                            free (inc_mat [1]);
                            inc_mat [1] = NULL;
                            free (inc_mat);
                            inc_mat = NULL;
                        }


                        printf ("\n");

                        unsigned int **** positional_index = build_positional_index (&doc_tokens, &size, doc_tokens_size);
                        if (positional_index != NULL) {
                            printf ("Print The Inverted Index Part:\n");
                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                printf ("The term is: %s. Its docFrequency is: %u. Its terFrequency is: %u\n", tokens [counter], positional_index [0][0][0][counter], positional_index [0][1][0][counter]);
                                printf ("The posting list is:\n\t");
                                for (unsigned int inside = 0; inside < positional_index [0][0][0][counter]; ++inside)
                                    printf ("%u  ", positional_index [0][2][counter][inside]);
                                printf ("\n\n");
                            }

                            printf ("\nPrinting the positioning list for all of the terms:\n");
                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                printf ("Positioning list for term: %s.\n", tokens [counter]);
                                for (unsigned int docs = 0; docs < positional_index [0][0][0][counter]; ++docs) {
                                    printf ("The positions of that term in doc %u is:\n\t", (docs + 1));
                                    for (unsigned int pos = 0; pos < positional_index [1][counter][docs][0]; ++pos)
                                        printf ("%u  ", positional_index [1][counter][docs][(pos + 1)]);
                                    
                                    printf ("\n");
                                }
                                printf ("\n\n");
                            }

                            printf ("\n\n");

                            for (unsigned int counter = 0; counter < mps_size; ++counter) {
                                for (unsigned int docs = 0; docs < positional_index [0][0][0][counter]; ++docs) {
                                    free (positional_index [1][counter][docs]);
                                    positional_index [1][counter][docs] = NULL;
                                }

                                free (positional_index [1][counter]);
                                positional_index [1][counter] = NULL;
                            }

                            free (positional_index [1]);
                            positional_index [1] = NULL;

                            free (positional_index [0][0][0]);
                            positional_index [0][0][0] = NULL;
                            free (positional_index [0][0]);
                            positional_index [0][0] = NULL;
                            free (positional_index [0][1][0]);
                            positional_index [0][1][0] = NULL;
                            free (positional_index [0][1]);
                            positional_index [0][1] = NULL;

                            for (unsigned int counter = 0; counter < mps_size; free (positional_index [0][2][counter]), positional_index [0][2][counter] = NULL, ++counter);
                            free (positional_index [0][2]);
                            positional_index [0][2] = NULL;
                            free (positional_index [0]);
                            positional_index [0] = NULL;

                            free (positional_index);
                            positional_index = NULL;
                        }


                        mps dictionary = build_mps (&doc_tokens, &size, doc_tokens_size, 1, 3);
                        if (dictionary != NULL) {
                            unsigned int * _1 = get_posting_of (&dictionary, &mps_size, &size, "oi");
                            if (_1 != NULL) {
                                for (unsigned int counter = 1; counter <= _1 [0]; printf ("%u  ", _1 [counter]), ++counter);
                                free (_1);
                                _1 = NULL;
                            }

                            printf ("Hello\n\n");

                            print_mps (&dictionary, &mps_size, &size, &largest_length);
                            
                            tfidf _tfidf = build_tfidf (&doc_tokens, &size, doc_tokens_size);
                            if (_tfidf != NULL) {
                                print_tfidf (&_tfidf, &dictionary, &mps_size, &size, &largest_length);
                                printf ("\n\n");

                                printf ("Enter the query: ");
                                string query = check_input (stdin, 10);

                                if (query != NULL) {
                                    unsigned int * result = process_query (&query, &dictionary, &mps_size, &_tfidf, &doc_tokens, &size, doc_tokens_size);
                                    if (result != NULL) {
                                        printf ("Query is found in the following documents: ");
                                        for (unsigned int counter = 0; counter < result [0]; printf ("%u  ", result [(counter + 1)]), ++counter);
                                        free (result);
                                        result = NULL;
                                    } else
                                        printf ("No document found.\n\n");
                                } else
                                    printf ("You can not enter an empty query\n\n");

                                
                                if (terminate_tfidf (&_tfidf, &mps_size))
                                    printf ("\n\nTFIDF is terminated.\n\n");
                                else
                                    printf ("\n\nProblem in terminating TFIDF.\n\n");
                            }

                            printf ("\n\n");


                            if (terminate_mps (&dictionary, &mps_size))
                                printf ("MPS is terminated successfuly.\n\n");
                            else
                                printf ("There is a problem in terminating MPS.\n\n");
                        } else
                            printf ("\nMPS_FAILED\n\n");

                        
                        for (unsigned int counter = 0; counter < meta [0]; free (tokens [counter]), tokens [counter] = NULL, ++counter);

                        for (unsigned int counter = 0; counter < size; free (doc_tokens [counter]), doc_tokens [counter] = NULL, ++counter)
                            for (unsigned int inside = 0; inside < doc_tokens_size [counter]; free (doc_tokens [counter][inside]), doc_tokens [counter][inside] = NULL, ++inside);
                        
                        
                        free (meta);
                        meta = NULL;
                        free (tokens);
                        tokens = NULL;
                        free (doc_tokens);
                        doc_tokens = NULL;
                        free (doc_tokens_size);
                        doc_tokens_size = NULL;
                        
                    }

                    for (unsigned int counter = 0; counter < size; free (documents [counter]), documents [counter] = NULL, ++counter)
                        for (unsigned int inside = 0; inside < document_size [counter]; free (documents [counter][inside]), documents [counter][inside] = NULL, ++inside);
                    
                    free (documents);
                    documents = NULL;

                    term_delimiter ();
                    term_stop_words ();

                    printf ("\n");

                    return EXIT_SUCCESS;
                } else {
                    printf ("Nothing to lower:\n");
                    for (unsigned int counter = 0; counter < size; free (documents [counter]), documents [counter] = NULL, ++counter)
                        for (unsigned int inside = 0; inside < document_size [counter]; free (documents [counter][inside]), documents [counter][inside] = NULL, ++inside);
                    
                    free (documents);
                    documents = NULL;

                    return EXIT_FAILURE;
                }
            } else {
                printf ("Can not get input from a file:\n");
                free (file_names);
                file_names = NULL;
                return EXIT_FAILURE;
            }
        } else
            return EXIT_FAILURE;
    } else
        return EXIT_FAILURE;