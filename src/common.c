#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "../header/common.h"


/*
INPUT: Non
OUTPUT: Non
INFO: Waving hand at the middel
*/
void hm (void) {
    printf ("\t\t\t\t\t                             /\\\n");
    printf ("\t\t\t\t\t                       /\\   |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                /\\    |  |__|  |__|  |__|  |\n");
    printf ("\t\t\t\t\t               /  \\  /                     |\n");
    printf ("\t\t\t\t\t              /  /__/                      |\n");
    printf ("\t\t\t\t\t              \\                            |\n");
    printf ("\t\t\t\t\t               \\                          /\n");
    printf ("\t\t\t\t\t                \\                        /\n");
    printf ("\t\t\t\t\t                 \\                      /\n");
    printf ("\t\t\t\t\t                  \\                    /\n");
    printf ("\t\t\t\t\t                   \\                  /\n");
    printf ("\t\t\t\t\t                    \\                /\n");
    printf ("\t\t\t\t\t                     \\              |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\t\t\t\t\t                      |             |\n");
    printf ("\n");
}


/*
INPUT: Non
OUTPUT: Non
INFO: Waving hand at the left
*/
void hl (void) {
    printf ("\t\t\t\t\t                             /\\\n");
    printf ("\t\t\t\t\t                       /\\   |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                /\\    |  |__|  |__|  |__|  |\n");
    printf ("\t\t\t\t\t               /  \\  /                     |\n");
    printf ("\t\t\t\t\t              /  /__/                      |\n");
    printf ("\t\t\t\t\t              \\                            |\n");
    printf ("\t\t\t\t\t               \\                          /\n");
    printf ("\t\t\t\t\t                \\                        /\n");
    printf ("\t\t\t\t\t                 \\                      /\n");
    printf ("\t\t\t\t\t                  \\                    /\n");
    printf ("\t\t\t\t\t                   \\                  /\n");
    printf ("\t\t\t\t\t                    \\                /\n");
    printf ("\t\t\t\t\t                     \\               \\\n");
    printf ("\t\t\t\t\t                      \\               \\\n");
    printf ("\t\t\t\t\t                       \\               \\\n");
    printf ("\t\t\t\t\t                        \\               \\\n");
    printf ("\t\t\t\t\t                         \\               \\\n");
    printf ("\t\t\t\t\t                          \\               \\\n");
    printf ("\t\t\t\t\t                           \\               \\\n");
    printf ("\t\t\t\t\t                            \\               \\\n");
    printf ("\t\t\t\t\t                             \\               \\\n");
    printf ("\t\t\t\t\t                              \\               \\\n");
    printf ("\t\t\t\t\t                               \\               \\\n");
    printf ("\t\t\t\t\t                                \\               \\\n");
    printf ("\t\t\t\t\t                                 \\               \\\n");
    printf ("\n");
}


/*
INPUT: Non
OUTPUT: Non
INFO: Waving hand at the right
*/
void hr (void) {
    printf ("\t\t\t\t\t                             /\\\n");
    printf ("\t\t\t\t\t                       /\\   |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |   /\\\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                      |  |  |  |  |  |  |  |\n");
    printf ("\t\t\t\t\t                /\\    |  |__|  |__|  |__|  |\n");
    printf ("\t\t\t\t\t               /  \\  /                     |\n");
    printf ("\t\t\t\t\t              /  /__/                      |\n");
    printf ("\t\t\t\t\t              \\                           /\n");
    printf ("\t\t\t\t\t               \\                         /\n");
    printf ("\t\t\t\t\t                \\                       /\n");
    printf ("\t\t\t\t\t                 |                     /\n");
    printf ("\t\t\t\t\t                 |                    /\n");
    printf ("\t\t\t\t\t                /                    /\n");
    printf ("\t\t\t\t\t               /                    /\n");
    printf ("\t\t\t\t\t              /                    /\n");
    printf ("\t\t\t\t\t             /                    /\n");
    printf ("\t\t\t\t\t            /                    /\n");
    printf ("\t\t\t\t\t           /                    /\n");
    printf ("\t\t\t\t\t          /                    /\n");
    printf ("\t\t\t\t\t         /                    /\n");
    printf ("\t\t\t\t\t        /                    /\n");
    printf ("\t\t\t\t\t       /                    /\n");
    printf ("\t\t\t\t\t      /                    /\n");
    printf ("\t\t\t\t\t     /                    /\n");
    printf ("\t\t\t\t\t    /                    /\n");
    printf ("\t\t\t\t\t   /                    /\n");
    printf ("\t\t\t\t\t  /                    /\n");
    printf ("\n");
}


/*
INPUT: Non.
OUTPUT: Non.
INFO: This function is used to pring waving hand animation.
*/
void print_bye (void) {
    for (unsigned int counter = 0; counter < 5; ++counter) {
        clear_screen ();
        hm ();
        printf ("\t\t\t\t\t\t\t\t  GoodBye");
        Sleep (10);
        if (counter == 4)
            break;

        clear_screen ();
        hl ();
        printf ("\t\t\t\t\t\t\t\t\t\tGoodBye");
        Sleep (10);
        clear_screen ();
        hm ();
        printf ("\t\t\t\t\t\t\t\t  GoodBye");
        Sleep (10);
        clear_screen ();
        hr ();
        printf ("\t\t\t\t\t      GoodBye");
        Sleep (10);
    }

    printf ("\n\n");
}


/*
INPUT: None.
OUTPUT: None.
INFO: This function is used to print the logo of the project.
*/
void print_logo (void) {
    clear_screen ();

	SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\t\t\t                          ______\n");
    printf ("\t\t\t                         /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/\\\n");
    printf ("\t\t\t                        /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                       /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\                                     ______\n");
    printf ("\t\t\t                      /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                                    /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/|\n");
    printf ("\t\t\t                     /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                                    /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                    /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                                    /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                   /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\                                   /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                  /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("........");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\                                 /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (" ...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                 /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..........");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\                               /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("  ...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                /_____/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("............");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\        ______               /_____/   ");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\n");
    printf ("\t\t\t                \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\      /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/\\              \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\   ");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|\\\n");
    printf ("\t\t\t                 \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/  \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\    /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\              \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\  ");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                  \\");
    printf ("_____\\/    \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\  /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\              \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\ ");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                               \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/               \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("...");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                 \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                 \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                   \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("|");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                  \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                     \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\|\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                  /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                       \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\ \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                 /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                         \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\ \\_____\\\n");
    printf ("\t\t\t                                /");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                           \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\   \n");
    printf ("\t\t\t                               /_______/");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                             \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\    \n");
    printf ("\t\t\t                               \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                               \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\   \n");
    printf ("\t\t\t                                \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".......");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf ("..");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("/                                 \\");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 3);
    printf (".....");
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 6);
    printf ("\\\n");
    printf ("\t\t\t                                 \\_______\\/                                   \\_____\\\n\n\n\n");
	SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), 7);
}


/*
INPUT: None.
OUTPUT: None.
INFO: This function is used to choose the write command to clear terminal screen.
        The choosing processing is done only in precprocessing step of compilation.
*/
void clear_screen (void) {
    #if _WIN32
        system ("cls");
    #else
        system ("clear");
    #endif
}


/*
INPUT: Non.
OUTPUT: Non.
INFO: This function is used to print the Processing animation
*/
void print_processing (void) {
    for (unsigned char counter = 0; counter < 4; ++counter) {
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t                               Processing\n\n");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\t\t\t\t\t                               __________\n");
        printf ("\t\t\t\t\t                             /|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                            /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                           /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                          |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                           \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                            \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                             \\|__________|\n");

        if (counter == 4) {
            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
            break;
        }

        Sleep (8);
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t                               Processing\n\n");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);

        printf ("\t\t\t\t\t                                __\n");
        printf ("\t\t\t\t\t                              /\\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                             /  \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                            /    \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                           /      \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                          /        \\__\\\n");
        printf ("\t\t\t\t\t                         /        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                        /        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                      /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("      /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                    /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("    /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                   /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("   /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                  /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("  /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                 /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf (" /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf(" /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t               /_______ /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t               \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                 \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                  \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                   v___/\n");

        Sleep (8);
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t                               Processing\n\n");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);

        printf ("\t\t\t\t\t                         __________________________________________\n");
        printf ("\t\t\t\t\t                        /|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("........................................");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/|\n");
        printf ("\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......................................");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                      /__|______________________________________/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                     |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|                                      |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                     |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|______________________________________|");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("|\n");
        printf ("\t\t\t\t\t                     |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/                                       |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                     |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/                                        |");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                     |/_________________________________________|/\n");

        Sleep (8);
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t                               Processing\n\n");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);

        printf ("\t\t\t\t\t                    ________\n");
        printf ("\t\t\t\t\t                  /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\\\n");
        printf ("\t\t\t\t\t                 /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t               /_________/");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t               \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                 \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf("\\\n");
        printf ("\t\t\t\t\t                  \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                   \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                    \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                     \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf (".......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("\\\n");
        printf ("\t\t\t\t\t                      \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                       \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                        \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 9);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
        printf ("/\n");
        printf ("\t\t\t\t\t                         \\_________\\/\n");

        Sleep (8);
    }

    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf ("\n\n");
}


/*
INPUT: A string which hold a message to be displayed if nothing is sent, then a defult message will appear "There Is An Error, Please Try Again".
OUTPUT: Non.
INFO: This function is used to print an x with red and text indicating and error animation
*/
void print_error (string message) {
    for (unsigned char counter = 0; counter < 5; ++counter) {
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t                            ___________        __________\n");
        printf ("\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\           \\      /          /\\\n");
        printf ("\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\           \\    /          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\           \\  /          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                       \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\           \\/          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\                     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\                   /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                          \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\                 /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                           \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\               /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                            \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\             /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                             /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/             \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                            /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/               \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                           /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/                 \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/                   \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/          /\\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/          /  \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\\\n");
        printf ("\t\t\t\t\t                        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/          /    \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/          /      \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t                          \\/__________/        \\_________\\/\n");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\n\n");
        if (message != NULL)
            printf ("\t\t\t\t\t                                   %s.", message);
        else
            printf ("\t\t\t\t\t                                   There Is An Error.");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);

        Sleep (12);
        clear_screen ();

        //Inverted Color
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\t\t\t\t\t                            ___________        __________\n");
        printf ("\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\           \\      /          /\\\n");
        printf ("\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("...");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\           \\    /          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\           \\  /          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                       \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\           \\/          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\                     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\                   /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                          \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\                 /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                           \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\               /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                            \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\             /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                             /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/             \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                            /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/               \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                           /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/                 \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/                   \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/          /\\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/          /  \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf (".....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("\\\n");
        printf ("\t\t\t\t\t                        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/          /    \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/          /      \\         \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
        printf ("/\n");
        printf ("\t\t\t\t\t                          \\/__________/        \\_________\\/\n");


        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\n\n");
        if (message != NULL)
            printf ("\t\t\t\t\t                                   %s.", message);
        else
            printf ("\t\t\t\t\t                                   There Is An Error.");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    }

    printf ("\n\n");
}


/*
INPUT: A string which holds a message or otherwise a default message will appear
OUTPUT: Non
INFO: This function is used to print / that represent success.
                                    v
*/
void print_success (string message) {
    for (unsigned int counter = 0; counter < 5; counter++) {
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("\t\t\t\t\t\t\t                           ________\n");
        printf ("\t\t\t\t\t\t\t                          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                      /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t           ________ /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t          \\        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t           \\      / \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t            \\    /   \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t             \\  /     \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t              \\/_______\\/\n");
        printf ("\n\n");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t\t\t              %s.\n\n", message);

        Sleep (15);
        clear_screen ();

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("\t\t\t\t\t\t\t                           ________\n");
        printf ("\t\t\t\t\t\t\t                          /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                         /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                        /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                       /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                      /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t                     /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t           ________ /");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t          \\        \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("........");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t           \\      / \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("......");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t            \\    /   \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("....");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t             \\  /     \\");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("..");
        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
        printf ("/\n");
        printf ("\t\t\t\t\t\t\t              \\/_______\\/\n");
        printf ("\n\n");

        SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
        printf ("\t\t\t\t\t\t\t              %s.\n\n", message);

        Sleep (15);
    }

    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
}


/*
INPUT: None.
OUTPUT: None.
INFO: This function is used to print the table of functions that can be done.
*/
void print_algorithm_table (void) {
    printf ("\t\t\t\t\t\t\t\t _____________________________________\n");
    printf ("\t\t\t\t\t\t\t\t|                                     |\n");
    printf ("\t\t\t\t\t\t\t\t|          ");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
    printf ("Algorithms options");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf (":        |\n");
    printf ("\t\t\t\t\t\t\t\t|         ");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 1);
    printf ("======================");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf ("      |\n");
    printf ("\t\t\t\t\t\t\t\t|                                     |\n");
    printf ("\t\t\t\t\t\t\t\t|           1.");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 3);
    printf ("Incidence Matrix");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf (".       |\n");
    printf ("\t\t\t\t\t\t\t\t|                                     |\n");
    printf ("\t\t\t\t\t\t\t\t|           2.");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
    printf ("Inverted Index");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf (".         |\n");
    printf ("\t\t\t\t\t\t\t\t|                                     |\n");
    printf ("\t\t\t\t\t\t\t\t|           3.");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 5);
    printf ("Positional Index");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf (".       |\n");
    printf ("\t\t\t\t\t\t\t\t|                                     |\n");
    printf ("\t\t\t\t\t\t\t\t|           4.");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 6);
    printf ("Exit");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
    printf (".                   |\n");
    printf ("\t\t\t\t\t\t\t\t|_____________________________________|\n");
    printf ("\n\n");
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
}


/*
INPUT: A pointer to 3d array of string which hold our documents, a pointer to an unsigned int which hold the number of documents and an array of unsigned int which hold the size of each document.
OUTPUT: Return 4d array of type void if the tokenizing proces os done correctly, or NULL otherwise
INFO: This function is used to tokenize the document data.
    The return should contains two indicies. The first index hold the 3d array of the tokens and the second index hold a 1d array which hold the number of tokens in each document.
*/
void **** tokenize (string *** documents, unsigned int * n_docs, unsigned int * document_size) {
    if (documents != NULL && n_docs != NULL && document_size != NULL) { //check if the passed arguments are passed correctly.
        if ((*documents) != NULL && (*n_docs) != 0) { //Check if the passed arguments points and hold the right data
            _Bool dmto = 0; //Which indicates the delimiter length is more than 1. Stands for delimiter more than one
            string ** tokens = NULL; //Which will hold tokens for each document.
            unsigned int * tokens_size = NULL; //hold the number of tokens for each document

            if (str_len (&__DELIMITER__) > 1) //Check if the length of the delimiter length more than one
                dmto = 1;

            do {tokens = (string **) calloc ((*n_docs), sizeof (string *));} while (tokens == NULL); //Allocate space for tokens
            do {tokens_size = (unsigned int *) calloc ((*n_docs), sizeof (unsigned int));} while (tokens_size == NULL); //Allocate space for tokens size

            for (unsigned int counter = 0; counter < (*n_docs); ++counter) { //For each document
                _Bool abort = 0; //Which indicates that an error occured in that document so deallocate all spaces and return NULL
                unsigned int * meta = NULL; //Hold information about the tokens in that document like [Total number of tokens in that doc - number lines - number of tokens in each line, that if added up give the first index]
                string ** doc_tokens = NULL; //Hold the tokens in each line of the document.

                //Allocate space for the meta data about the tokens for that document.
                do {meta = (unsigned int *) calloc ((document_size [counter] + 2), sizeof (unsigned int));} while (meta == NULL);
                meta [1] = document_size [counter]; //Put the number of lines in that document.

                do {doc_tokens = (string **) calloc (document_size [counter], sizeof (string *));} while (doc_tokens == NULL); //Allocate space for doc_tokens

                for (unsigned int inside = 0; inside < document_size [counter]; ++inside) { //For each line in the document
                    void *** content = NULL; //Hold the return of these function [str_char_split & str_word_split]

                    if (dmto) //Check if the delimiter's length is more than 1
                        content = str_word_split (&((*documents) [counter][inside]), __DELIMITER__); //Means our delimiter holds more than 1 character
                    else
                        content = str_char_split (&((*documents) [counter][inside]), __DELIMITER__ [0]); //Means our delimiter holds only 1 character

                    if (content == NULL) { //Check if the return is NULL. If it is, then it means the line did not have any delimiter value to split upon. So we take the whole line as a token.
                        string * holder = NULL; //Place which hold list of strings
                        do {holder = (string *) malloc (sizeof (string) * 2);} while (holder == NULL);
                        
                        holder [0] = NULL;
                        do {holder [0] = (string) malloc (sizeof (char) * 2);} while (holder [0] == NULL);
                        holder [0][0] = 1;
                        holder [0][1] = '\0';

                        holder [1] = give_me_str_copy (&((*documents) [counter][inside])); //The token

                        doc_tokens [inside] = holder;

                        holder = NULL;
                        ++meta [0]; //Increment the size by 1, as the line only holds one token
                        meta [(inside + 2)] = 1; //That line only contains one token. which is the whole line.

                    } else { //Means split happens
                        doc_tokens [inside] = ((string *) content [1]); //Tokens of that line
                        meta [0] += *((unsigned int *) content [0][0]); //Increment the total number of tokens by the the number of tokens in that doc.
                        meta [(inside + 2)] = *((unsigned int *) content [0][0]); //Put the number of tokens in that line.

                        //Free the content.
                        free (content [0][0]);
                        content [0][0] = NULL;
                        content [1] = NULL;
                        free (content);
                        content = NULL;
                    }
                }
                
                if (!degrade_list_1 (&tokens, &doc_tokens, &counter, meta)) { //degrade the doc_token which turn 3d to 2d array
                    for (unsigned int inside = counter; inside >= 0; free (tokens [inside]), tokens [inside] = NULL, --inside) //Deallocate space for tokens var
                        for (unsigned int inside_1 = 0; inside_1 < tokens_size [inside]; free (tokens [inside][inside_1]), tokens [inside][inside_1] = NULL, ++inside_1);
                    
                    free (tokens);
                    tokens = NULL;

                    free (tokens_size); //Deallocate space for tokens_size
                    tokens_size = NULL;

                    abort = 1; //Set abort to 1 which indicates an error has occured.
                }

                tokens_size [counter] = meta [0]; //Assing the total number of tokens in that document to the array that hold the total number of tokens per document. which will be returned.

                //Deallocate space for the doc_tokens var
                for (unsigned int inside = 0; inside < document_size [counter]; free (doc_tokens [inside][0]), doc_tokens [inside][0] = NULL, free (doc_tokens [inside]), doc_tokens [inside] = NULL, ++inside)
                    for (unsigned int inside_1 = 1; inside_1 <= split_len (&doc_tokens [inside][0]); free (doc_tokens [inside][inside_1]), doc_tokens [inside][inside_1] = NULL, ++inside_1);
                
                free (doc_tokens);
                doc_tokens = NULL;

                free (meta);
                meta = NULL;

                //checks if abort is set to 1 return NULL, otherwise go to the next document.
                if (abort)
                    return NULL;

            }

            //Define our return value
            void **** data = NULL;
            do {data = (void ****) malloc (sizeof (void ***) * 2);} while (data == NULL);
            data [0] = (void ***) tokens;
            tokens = NULL;
            data [1] = NULL;

            do {data [1] = (void ***) malloc (sizeof (void **));} while (data [1] == NULL);
            data [1][0] = NULL;

            do {data [1][0] = (void **) malloc (sizeof (void *));} while (data [1][0] == NULL);
            data [1][0][0] = (void *) tokens_size;
            tokens_size = NULL;

            return data;
        } else
            return NULL;
    } else
        return NULL;
}


/*
INPUT: None.
OUTPUT: Return 1 if the __DELIMITER__ variable is allocated successfully, otherwise return 0.
INFO: This function is used to set a delimiter when we tokenizing the documents.
*/
_Bool init_delimiter (void) {
    if (__DELIMITER__ == NULL) {
        do {__DELIMITER__ = (string) malloc (sizeof (char) * 2);} while (__DELIMITER__ == NULL);
       
        //The initial delimiter is a white space.
        __DELIMITER__ [0] = ' ';
        __DELIMITER__ [1] = '\0';

        return 1;
    } else
        return 0;
}


/*
INPUT: None.
OUTPUT: Return 1 if the de-allocation of the __DELIMITER__ is done successfully, otherwise return 0.
INFO: This function is used to de-allocate the space for delimiter variable.
*/
_Bool term_delimiter (void) {
    if (__DELIMITER__ != NULL) {
        free (__DELIMITER__);
        __DELIMITER__ = NULL;

        return 1;
    } else
        return 0;
}


/*
INPUT: None.
OUTPUT: Return 1 if the sop words array is allocated, otherwise return 0.
INFO: This function is used to create a stoping word list. At the beginning of the application and delete it when the application is ended.
	STOP_WORDS: [is - a - an - the - that - those - these - are - was - were - it - been - because - before - but - am - so - than - then - by - i - it - its -
		to - we - us - what - when - where - who - how]
	
	Size: 31.
	
	There is more, but that the common.
*/
_Bool init_stop_words (void) {
    if (_STOP_WORDS_ == NULL) {
        do {_STOP_WORDS_ = (string *) malloc (sizeof (string) * 32);} while (_STOP_WORDS_ == NULL);
        for (unsigned int counter = 0; counter < 32; _STOP_WORDS_ [counter] = NULL, ++counter);
        
        _STOP_WORDS_ [0] = "is";
        _STOP_WORDS_ [1] = "a";
        _STOP_WORDS_ [2] = "an";
        _STOP_WORDS_ [3] = "the";
        _STOP_WORDS_ [4] = "that";
        _STOP_WORDS_ [5] = "those";
        _STOP_WORDS_ [6] = "these";
        _STOP_WORDS_ [7] = "are";
        _STOP_WORDS_ [8] = "was";
        _STOP_WORDS_ [9] = "were";
        _STOP_WORDS_ [10] = "it";
        _STOP_WORDS_ [11] = "been";
        _STOP_WORDS_ [12] = "because";
        _STOP_WORDS_ [13] = "before";
        _STOP_WORDS_ [14] = "but";
        _STOP_WORDS_ [15] = "am";
        _STOP_WORDS_ [16] = "so";
        _STOP_WORDS_ [17] = "than";
        _STOP_WORDS_ [18] = "then";
        _STOP_WORDS_ [19] = "by";
        _STOP_WORDS_ [20] = "i";
        _STOP_WORDS_ [21] = "it";
        _STOP_WORDS_ [22] = "its";
        _STOP_WORDS_ [23] = "to";
        _STOP_WORDS_ [24] = "we";
        _STOP_WORDS_ [25] = "us";
        _STOP_WORDS_ [26] = "what";
        _STOP_WORDS_ [27] = "when";
        _STOP_WORDS_ [28] = "where";
        _STOP_WORDS_ [29] = "who";
        _STOP_WORDS_ [30] = "how";
        _STOP_WORDS_ [31] = "of";

        return 1;
    } else
        return 0;
}


/*
INPUT: None.
OUTPUT: Return 1 if the stop words array is de-allocated, otherwise return 0.
INFO: This function will deallocate the space allocated for stop words.
*/
_Bool term_stop_words (void) {
    if (_STOP_WORDS_ != NULL) {
        free (_STOP_WORDS_);
        _STOP_WORDS_ = NULL;

        return 1;
    } else
        return 0;
}


/*
INPUT: A pointer to a string which hold the main string.
OUTPUT: Return 1 if the word contains a hyphen, otherwise return 0.
INFO: This function is used to check if the string contain a hyphen.
*/
_Bool is_hyphen (string * _word) {
    if (_word != NULL) { //Check if the passed argument is not null
        if ((*_word) != NULL) { //Check if the address does not point to null value.
            unsigned int _word_size = str_len (_word); //get the size of the word (Passed argument).

            if (_word_size > 0) { //Check if the size of the word is bigger than 0
                for (unsigned int counter = 0; counter < _word_size; ++counter) //Loop unitil the end of the string.
                    if ((*_word) [counter] == '-') //If the character is equal to hyphen return 1
                        return 1;
                
                return 0; //Means the string does not contain a hypen.
            } else
                return 0;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to unsigned int which hold the amount to print spaces.
OUTPUT: Non.
INFO: This function is used to print amount of spaces, depending upon the value of the px.
*/
_Bool padding (unsigned int * px) {
    if (px != NULL) {
        for (unsigned int counter = 0; counter < (*px); printf (" "), ++counter);
        return 1;
    } else
        return 0;
}


/*
INPUT: A pointer to a string which hold a token.
OUTPUT: Return 1 if the token is a stop word, otherwise return 0.
INFO: This function is used to check if the token is a stop word.
*/
_Bool is_stop_word (string * _word) {
    if (_word != NULL) {
        if ((*_word) != NULL) {
            if (str_len (_word) >= 1) {
                for (unsigned int counter = 0; counter < 32; ++counter)
                    if (compare_string (_word, _STOP_WORDS_ [counter])) //If the value of the token is the same as any existing value of stop words, returns 1.
                        return 1;
                return 0; //Means the token is not a 
            } else
                return 0; //The string user sent of 0 size.
        } else
            return 0; //The string is NULL.
    } else
        return 0; //The input of the function is NULL.
}


/*
INPUT: a string which hold a new delimiter.
OUTPUT: Return 1 if the changes done, otherwise return 0.
INFO: This function is uesed to change the current delimiter to a new delimiter.
*/
_Bool change_delimiter (string delimiter) {
    if (delimiter != NULL && __DELIMITER__ != NULL) {
        if (str_len (&delimiter) >= 1) {
            if (!compare_string (&__DELIMITER__, delimiter)) {
                if (string_override (&__DELIMITER__, delimiter))
                    return 1;
                else
                    return 0;
            } else
                return 0;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a string which hold the main the string.
OUTPUT: Return 1 if it is a keyword, otherwise return 0.
INFO: This function is used to check if the string is keyword [and - or - not - and not - or not]
        Also check if the following key word is there invert it [not or - not AND] convert to [and not - or not].
*/
_Bool is_boolean_keyword (string * keyword) {
    if (keyword != NULL) {
        if ((*keyword) != NULL) {
            unsigned int keyword_size = str_len (keyword);

            if (keyword_size >= 2) {
                if (compare_string (keyword, "and")) {
                    return 1;
                } else if (compare_string (keyword, "not")) {
                    return 1;
                } else if (compare_string (keyword, "or")) {
                    return 1;
                } else if (compare_string (keyword, "and not")) {
                    return 1;
                } else if (compare_string (keyword, "or not")) {
                    return 1;
                } else if (compare_string (keyword, "not or")) {
                    if (string_override (keyword, "or not"))
                        return 1;
                    else
                        return 0;
                } else if (compare_string (keyword, "not and")) {
                    if (string_override (keyword, "and not"))
                        return 1;
                    else
                        return 0;
                } else
                    return 0;
            } else
                return 0;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a string which hold document, token or query.
OUTPUT: Return 1 if the changes happened or the input is already lower case, otherwise return 0.
INFO: This function i used to convert upper case letters to lower case.
*/
_Bool lower_input (string * document_token_query) {
    if (document_token_query != NULL) { //Check if the input does not equal to NULL.
        if ((*document_token_query) != NULL) { //Check if the dereferencing does not equal to NULL.
            unsigned int input_size = str_len (document_token_query); //Get the size of the input.

            if (input_size > 0) { //Check if the size of the input does not equal to 0.
                for (unsigned int counter = 0; counter < input_size; ++counter)
                    if (is_char_alpha ((*document_token_query) [counter]))
                        if (is_char_upper ((*document_token_query) [counter]))
                            (*document_token_query) [counter] = ((*document_token_query) [counter] + 32); //The lower case letter start from 97 and upper case start from 65, so the difference is 32.

                
                return 1;
            } else
                return 0;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an array of string, which will hold the document values the user will enter
    and a pointer to an unsigned int, which will hold the size of the document entered by the user.

OUTPUT: return 1 if the process of getting is done successfully, otherwise return 0.
INFO: This function is used to get the input from the user inorder to start the rest of the operation.
*/
_Bool get_input (string ** documents, unsigned int * document_size) {
    if (documents != NULL && document_size != NULL) {
        if ((*documents) == NULL) { //the array of string must be null as we will fill it ourselves.
            
            string input = NULL; //This variable will hold user data entered from the keyboard, then save it to the appropiate variables.
            printf ("Please Enter The Number Of Documents You Would Like To Enter: ");
            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);

            if ((input = check_input (stdin, 10)) != NULL) { 
                SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);  
                fflush (stdin); //To free any data in the keyboard buffer.
                printf ("\n");

                if (is_uint (&input)) { //This function is used to check if the input the user input represent unsigned int value or not.
                    (*document_size) = to_uint (&input); //return an unsigned int representation of the input the user enterd.

                    //Free the allocated space of input variable.
                    free (input);
                    input = NULL;

                    _Bool there_is_data = 0; //This value is there to check if there are stored values in the documents variable.
                                            //Use to de-allocated these spaces incase an error happend in the middle of the inputing.

                    if ((*document_size) > 0) { //To make sure the size is not the 0.
                        //Allocate space for the array of string the user sent.
                        do {(*documents) = (string *) malloc (sizeof (string) * (*document_size));} while ((*documents) == NULL);

                        //Now we loop till we reach the size of the user entered, for each time we get the user input and we store in the array of strings that the user sent.
                        printf ("Please Enter The Following Document Values:\n");
                        for (unsigned int counter = 0; counter < (*document_size); ++counter) {
                            printf ("\tThe Value For docID [");
                            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 5);
                            printf ("%u", (counter + 1));
                            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                            printf ("]: ");
                            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
                            if ((input = check_input (stdin, 50)) != NULL) { //Check for user input.
                            SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                                (*documents) [counter] = give_me_str_copy (&input); //Return a deep copy of the input and store in the document.
                                free (input); //Free the allocated space of the input variable.
                                input = NULL; //Fix the problem of making input variable a dangling pointer.
                                there_is_data = 1;
                                fflush (stdin); //Clear the keyboard buffer off any data before getting the next input.
                                printf ("\n");
                            } else {
                                SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                                if (there_is_data) {
                                    for (unsigned int inside = (counter - 1); inside >= 0; free ((*documents) [inside]), (*documents) [inside] = NULL, --inside);
                                    free ((*documents));
                                    (*documents) = NULL;
                                }

                                return 0;
                            }
                        }

                        return 1;
                    } else
                        return 0;
                } else
                    return 0;
            } else {
                SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                return 0;
            }
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an array of strings and a pointer to an unsigned integer which hold the size of the array.
OUTPUT: Return 1 if all stops words are dropped, otherwise return 0.
INFO: This function is used to drop all stopps words in the token list or from query and modify the array size if that happened
*/
_Bool drop_stop_words (string ** tokens, unsigned int * token_size) {
    if (tokens != NULL && token_size != NULL) { //Check that the arguments are passed correctly.
        if ((*tokens) != NULL && (*token_size) != 0) { //Check that the arguments points and hold the right data.
            string * new_list = NULL; //Hold the new list with no stopwords
            unsigned int real_size = 0; //Hold the number of tokens after removing stop words.

            //Allocate space for the new list.
            do {new_list = (string *) calloc ((*token_size), sizeof (string));} while (new_list == NULL);

            //For each token
            for (unsigned int counter = 0; counter < (*token_size); ++counter) {
                if (!is_stop_word (&((*tokens) [counter]))) //If the token is not a stop word, then make a copy of that token and put in the new list.
                    new_list [real_size++] = give_me_str_copy (&((*tokens) [counter]));
                
                //Remove that token. Either it is stop word or not.
                free ((*tokens) [counter]);
                (*tokens) [counter] = NULL;
            }
            
            //Free the old token list
            free ((*tokens));
            (*tokens) = NULL;

            //Check any token has been removed.
            if (real_size != (*token_size)) {
                //reallocate the new list to the new size.
                void * reallocation = NULL;
                do {reallocation = realloc (new_list, (sizeof (string) * real_size));} while (reallocation == NULL);

                //If the new allocates address is not the same
                if (reallocation != new_list)
                    (*tokens) = (string *) reallocation; //Assign the old list to the new reallocated list
                else //Means the allocation happend in the same place.
                    (*tokens) = new_list;
                
                reallocation = NULL;

                //Change the size of the token to the new size.
                (*token_size) = real_size;
            } else //Means there was no changes happend in the old list.
                (*tokens) = new_list;

            new_list = NULL;

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an array of string, and a pointer to an unisgned int which hold how many tokens in the array.
OUTPUT: Return 1 if the sorting is done successfuly, otherwise return 0.
INFO: This function is used to sort list tokens only by name.
*/
_Bool sort_term_token_2 (string ** tokens, unsigned int * n_tokens) {
    if (tokens != NULL && n_tokens != NULL) { //Check if the passed arguments is passed correctly
        if ((*tokens) != NULL && (*n_tokens) != 0) { //Check if the passed arguments points and holds the right data.
            //Bubble sort.
            for (unsigned int counter = 0; counter < (*n_tokens); ++counter)
                for (unsigned int inside = 0; inside < ((*n_tokens) - 1); ++inside)
                    if (which_is_bigger (&((*tokens) [inside]), &((*tokens) [(inside + 1)])) == 0) {
                        string temp = (*tokens) [inside];
                        (*tokens) [inside] = (*tokens) [(inside + 1)];
                        (*tokens) [(inside + 1)] = temp;
                        temp = NULL;
                    }
            
            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to 2d array of strings and a pointer to the size of that 2d array
OUTPUT: Return 1 if we can remove stop words, otherwise return 0;
INFO: This function sees if we can remove stop words.
*/
_Bool analyse_query_stop_words (string ** query, unsigned int * n_tokens) {
    if (query != NULL && n_tokens != NULL) { //Checks if the passed arguments are passed correctly
        if ((*query) != NULL && ((*n_tokens) != 0 && (*n_tokens) != 1)) { //Checks if the passed argument holds and points at the right data
            unsigned int stop_word = 0; //Hold the number of stop words
            unsigned int not_stop_word = 0; //Hold the number of none stop words

            //For each term of the query checks if it is stop word or not and increment the respective var
            for (unsigned int counter = 0; counter < (*n_tokens); (is_stop_word (&(*query) [counter]) == 1) ? stop_word++, ++counter : not_stop_word++, ++counter);

            if (not_stop_word == 0) //Checks if the query only contains stop words
                return 0; //Do not remove stop words
            else if (((*n_tokens) - stop_word) >= 1) //Checks if we removed stop word from the token list will it contain none stop words or not
                return 1; //Remove stop words
            else
                return 0; //Do not remove stop words
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an unsigned int which hold the length of the largest token and a _Bool value indicates are we building DocID column or not.
OUTPUT: Non
INFO: This function is used to print an empty line like that |                         |                       |. In the print_token function
*/
_Bool print_token_empty_line (unsigned int * largest_token, _Bool is_indexed) {
    if (largest_token != NULL) { //Checks if the passed arguments are passed correctly.
        if ((*largest_token) != 0) { //Checks if the passed arguments holds the right data.
            if (is_indexed) { //Check if printing the Doc ID column or not
                printf ("\t| ");
                for (unsigned int counter = 0; counter < ((*largest_token) + 2); printf (" "), ++counter);
                printf (" | ");
                for (unsigned char counter = 0; counter < 16; printf (" "), ++counter);
                printf (" |\n");
            } else { //Means we are not printing the Doc ID Column
                printf ("\t| ");
                for (unsigned int counter = 0; counter < ((*largest_token) + 2); printf (" "), ++counter);
                printf (" |\n");
            }

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an unsigned int which hold the length of the largest token and a _Bool value indicates are we building DocID column or not.
OUTPUT: Non
INFO: This function is used to print an empty line like that |------------------------|------------------------|. In the print_token function
*/
_Bool print_token_dashed_line (unsigned int * largest_token, _Bool is_indexed) {
    if (largest_token != NULL) { //Checks if the passed arguments are passed correctly.
        if ((*largest_token) != 0) { //Checks if the passed arguments holds the right data.
            if (is_indexed) { //Check if printing the Doc ID column or not
                printf ("\t| ");
                for (unsigned int counter = 0; counter < ((*largest_token) + 2); printf ("-"), ++counter);
                printf (" | ");
                for (unsigned char counter = 0; counter < 16; printf ("-"), ++counter);
                printf (" |\n");
            } else { //Means we are not printing the Doc ID Column
                printf ("\t| ");
                for (unsigned int counter = 0; counter < ((*largest_token) + 2); printf ("-"), ++counter);
                printf (" |\n");
            }

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to 2d array of strings and a pointer to an unsigned int which hold the number of tokens in the list.
OUTPUT: Return 1 if the list is updated, otherwise return 0.
INFO: This function is used to remove repeated tokens from a 2d array.
*/
_Bool remove_repeated_term_token_2 (string ** tokens, unsigned int * n_tokens) {
    if (tokens != NULL && n_tokens != NULL) { //Check if the passed arguments is passed correctly.
        if ((*tokens) != NULL && (*n_tokens) != 0) { //Checks if the passed arguments points and holds the right values
            unsigned int real_size = (*n_tokens); //hold the number of tokens.

            for (unsigned int counter = 0; counter < (*n_tokens); ++counter) //For each token
                if ((*tokens) [counter] != NULL) //Check if the token does not equal to null
                    for (unsigned int inside = 0; inside < (*n_tokens); ++inside) //loop again if the tookens to see for each token they will not be any duplication
                        if (counter != inside) //If the pointers not the same.
                            if ((*tokens) [inside] != NULL) //Check if inside does not point to null.
                                if (compare_string (&((*tokens) [counter]), (*tokens) [inside])) { //checks if the a token has a dunplicate
                                    free ((*tokens) [inside]); //remove the duplication
                                    (*tokens) [inside] = NULL;
                                    --real_size; //Decrease the size by one.
                                }

            if (real_size != (*n_tokens)) { //Checks if there any remoavl of duplications
                string * new_list = NULL; //Create new list.
                do {new_list = (string *) malloc (sizeof (new_list) * real_size);} while (new_list == NULL); //Allocate space for it.

                real_size = 0; //Reset the real_size to 0
                for (unsigned int counter = 0; counter < (*n_tokens); ++counter) //For each token
                    if ((*tokens) [counter] != NULL) { //Check if the token is not null
                        new_list [real_size++] = give_me_str_copy (&((*tokens) [counter])); //Make a deep copy of that token to the new list.
                        free ((*tokens) [counter]); //Remove the token from the old list.
                        (*tokens) [counter] = NULL;
                    }
                

                free ((*tokens)); //De-allocate space for the old list.
                (*tokens) = NULL;

                (*tokens) = new_list; //Assign the new list
                new_list = NULL;

                (*n_tokens) = real_size; //Update the size.
            }

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to an array of string and a pointer to an unsigned int which hold the size of the array.
OUTPUT: Return 1 if the we found hyphen and problem is solved, otherwise return 0.
INFO: This function is used to check if the tokens contains any hyphens, if there is solve it by adding another set of string of the same word
    but without a hyphen and with space after the word with hyphen. After that update the token array and token size.
*/
_Bool solve_hyphen_problems (string *** tokens, unsigned int * n_docs, unsigned int * token_size) {
    if (tokens != NULL && n_docs != NULL && token_size != NULL) { //Check if the passed arguments are passed correct.
		if ((*tokens) != NULL && (*n_docs) != 0) { //Check if the passed arguments contains the right data.
			for (unsigned int counter = 0; counter < (*n_docs); ++counter) { //For each document.
				unsigned int real_size = 0; //Hold the size of the new token list.
				string * updated_token = NULL; //Hold the new list of tokens.
				do {updated_token = (string *) calloc ((token_size [counter] * 3), sizeof (string));} while (updated_token == NULL); //Allocate space for it. 2 times the original size.
				
				for (unsigned int inside = 0; inside < token_size [counter]; ++inside) { //For each token
 					if (is_hyphen (&((*tokens) [counter][inside]))) { //Is it a hyphen.
						string temp = give_me_str_copy (&((*tokens) [counter][inside])); //Create a temp which hold the hyphen word.
						unsigned int hyphen_index = index_of (&temp, '-'); //Get the index of the first hyphen.
			
						//First thing, put the word as it is, with the hyphen.
						updated_token [real_size++] = give_me_str_copy (&((*tokens) [counter][inside]));
						
						//Replace the hyphen with space and add it to a new index.
						insert_at (&temp, hyphen_index, ' ');
						updated_token [real_size++] = give_me_str_copy (&temp);
						
						//Remove the space, and add it to a new index.
						remove_at (&temp, hyphen_index);
						updated_token [real_size++] = give_me_str_copy (&temp);
						
						//Free the temp.
						free (temp);
						temp = NULL;
						
					} else {
						//Get a new copy of that string.
						updated_token [real_size++] = give_me_str_copy (&((*tokens) [counter][inside]));
					}
					
					//Free the old token.
					free ((*tokens) [counter][inside]);
					(*tokens) [counter][inside] = NULL;
				}
				
				//Free the old token list for that document.
				free ((*tokens) [counter]);
				(*tokens) [counter] = NULL;
				
				//Check if the size matches after the updates.
				if (real_size == token_size [counter]) {
					(*tokens) [counter] = updated_token; //Change address.
					updated_token = NULL;
				} else { //Empty space needs to be deleted.
					//reallocate the new the token list.
					void * reallocation = NULL;
					do {reallocation = realloc (updated_token, sizeof (string) * real_size);} while (reallocation == NULL);
					
					//If the reallocation address is not the same.
					if (reallocation != updated_token)
						//Change to the new token list.
						(*tokens) [counter] = (string *) reallocation;
                    else //Means that the reallocation happend in the same address.
                        (*tokens) [counter] = updated_token;
					
					//Prevent dangling pointers.
					updated_token = NULL;
					reallocation = NULL;
					
					//Set the number of tokens of that document to the value of the real_size var.
					token_size [counter] = real_size;
				}
			}
			
			return 1;
		} else
			return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a 3d array of strings which hold the documents, an unsigned int which hold the number of documents
        and an array of unsigned int which hold the size of each document.

OUTPUT: Return Nothing.
INFO: This function is used to make documents and queries to lowercase characters.
*/
_Bool lower_all (string *** documents_query, unsigned int * n_docs, unsigned int * document_size) {
	if (documents_query != NULL && n_docs != NULL && document_size != NULL) { //Check if the input data is passed correctly
        if ((*documents_query) != NULL && (*n_docs) != 0) { //Check if we dereference the data, in the right format.
            //For each document, for each line convert lower case characters into upper case letters.
            for (unsigned int counter = 0; counter < (*n_docs); ++counter)
                for (unsigned int inside = 0; inside < document_size [counter]; ++inside)
                    lower_input (&(*documents_query) [counter][inside]);

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a 3d array of strings, a pointer to the number of documents, and an array holds the number of tokens per document.
OUTPUT: Return 1 if the sorting is done successfuly, otherwise return 0.
INFO: This function is used to sort each document's tokens.
*/
_Bool sort_term_token_1 (string *** doc_tokens, unsigned int * n_docs, unsigned int * n_tokens_per_doc) {
    if (doc_tokens != NULL && n_docs != NULL && n_tokens_per_doc != NULL) { //Check if the passed arguments is passed correctly.
        if ((*doc_tokens) != NULL && (*n_docs) != 0 && (*n_tokens_per_doc) != 0) { //Checks if the passed arguments points and holds the right data.
            for (unsigned int counter = 0; counter < (*n_docs); ++counter) //For each document.
                for (unsigned int inside_1 = 0; inside_1 < n_tokens_per_doc [counter]; ++inside_1) //Perform bubble sort.
                    for (unsigned int inside_2 = 0; inside_2 < (n_tokens_per_doc [counter] - 1); ++inside_2)
                        if (which_is_bigger (&((*doc_tokens) [counter][inside_2]), &((*doc_tokens) [counter][(inside_2 + 1)])) == 0) {
                            string temp = (*doc_tokens) [counter][inside_2];
                            (*doc_tokens) [counter][inside_2] = (*doc_tokens) [counter][(inside_2 + 1)];
                            (*doc_tokens) [counter][(inside_2 + 1)] = temp;
                            temp = NULL;
                        }
            
            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to 2d array of string which hold the tokens for all of the documents, a pointer to 2d array of string which hold , a pointer to an unsigned integer which 
    hold document index and a pointer to an unsigned integer which hold the size number of tokens in that documents

OUTPUT: Reutun 1 if degrading is done successfully, otherwise return 0.
INFO: This function is used to convert the token list from token list per line to token list per document.
*/
_Bool degrade_list_1 (string *** new_list, string *** old_list, unsigned int * index, unsigned int * meta) {  
    if (new_list != NULL && old_list != NULL && meta != NULL) { //check that the passed argument is passed correctly
        if ((*new_list) != NULL && (*old_list) != NULL && (*new_list) != (*old_list)) { //Check that the passed argument is pointing to the right thing.
            if (index != NULL) { //means that we degrade the list of token per line to list of token per document.
                if ((*new_list) [(*index)] == NULL) { //The new list of index must equal to NULL in order to do the processing.
                    do {(*new_list) [(*index)] = (string *) malloc (sizeof (string) * meta [0]);} while ((*new_list) [(*index)] == NULL); //Allocate space for the list

                    meta [0] = 0; //Set the first value of the meta to 0

                    //For each line loops through its token and make acopy of each token in that line and assign to that document.
                    for (unsigned int counter = 0; counter < meta [1]; ++counter)
                        for (unsigned int inside = 0; inside < meta [(2 + counter)]; ++inside)
                            (*new_list) [(*index)][meta [0]++] = give_me_str_copy (&(*old_list) [counter][(inside + 1)]);
                } else
                    return 0; 
            } else
                return 0;

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: string, which hold the file name, a pointer to an array of strings, which will hold the document values read from the file.
    a pointer to an unsigned int value which will hold the size of the data read from the file
    data we will get from the file is about query or document value.

OUTPUT: Return 1 if the process gathering data is a success, otherwise return 0.
INFO: This function is used to read document and query value from a file instead from the keyboard.
        The extension of the file must be "*.txt".
*/
_Bool get_input_from_file (string file_name, string ** documents_query, unsigned int * document_query_size) {
    if (file_name != NULL && documents_query != NULL && document_query_size != NULL) {
        if ((*documents_query) == NULL) {
            unsigned int file_name_size = str_len (&file_name); //Get the size of the file_name

            if (file_name_size > 4) { //Make sure the file name at lease contains more than 4 characters as we for sure know that we need to have ".txt" at the end.
                string extension = NULL; //Create a variable which hold what the last 4 characters of the file name contains and compare it to .txt to see if they are equal
                do {extension = (string) malloc (sizeof (char) * 5);} while (extension == NULL);
                extension [4] = '\0';

                for (char counter = 3; counter >= 0; extension [(3 - counter)] = file_name [(file_name_size - (counter + 1))], --counter);
                
                if (compare_string (&extension, ".txt")) {
                    free (extension); //Free the extension varaible after use.
                    extension = NULL;

                    FILE * file = NULL;
                    if ((file = fopen (file_name, "r")) != NULL) { //Check if the file does exist, and if it does open it, otherwise return 0.
                        (*document_query_size) = 0; //Set the document_query_size to 0.

                        string input = NULL; //Create a variable which will contain the data from the file. The maximum number of characters read in single line is 500 including the string terminator.
                        do {input = (string) calloc (501, sizeof (char));} while (input == NULL);

                        _Bool first_time = 1; //A variable to check if this the first time to initialize the documents_query variable.
                        _Bool at_least_one_line = 0; // A variable to check if at least i read a complete line sucessfuly that contain at least one character and that character does not equal '\n'

                        while (fgets (input, 500, file) != NULL) { //Loops until the file is empty
                            if (input [0] == '\n') { //checks if the line that reads begins with new line character or not, if it does, skip this round.
                                input [0] = '\0';
                                continue;
                            }

                            if (first_time) { //If first time then initialize the documents_query
                                do {(*documents_query) = (string *) malloc (sizeof (string) * (++(*document_query_size)));} while ((*documents_query) == NULL);
                                first_time = 0;
                            } else { //Reallocate the documents_query.
                                void * reallocation = NULL;
                                do {reallocation = realloc ((*documents_query), sizeof (string) * (++(*document_query_size)));} while (reallocation == NULL);

                                if (reallocation != (*documents_query)) //Check if the reallocation address is the same as the previous one.
                                    (*documents_query) = (string *) reallocation;
                                
                                reallocation = NULL;
                            }

                            (*documents_query) [((*document_query_size) - 1)] = give_me_str_copy (&input); //Create a deep copy of the string.
                            if ((*documents_query) [((*document_query_size) - 1)][(str_len (&(*documents_query) [((*document_query_size) - 1)]) - 1)] == '\n') //Check if the string end with new line character, then delete it.
                                remove_at (&(*documents_query) [((*document_query_size) - 1)], (str_len (&(*documents_query) [((*document_query_size) - 1)]) - 1));

                            at_least_one_line = 1;
                            
                            free (input); //Free the input.
                            input = NULL;
                            
                            do {input = (string) calloc (501, sizeof (char));} while (input == NULL); //Reallocate it again for another new use.
                        }

                        free (input);
                        input = NULL;

                        fclose (file); //close the opened file.
                        
                        if (at_least_one_line) //check if we read at least one line, to know what to return.
                            return 1;
                        else
                            return 0;
                    } else
                        return 0;
                } else {
                    free (extension);
                    extension = NULL;
                    return 0;
                }
            } else
                return 0;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: a pointer to a 3d array of string, a pointer to an unsigned int which holds the number of documents and an array which hold the number of tokens in each document
OUTPUT: Return 1 if the removal is successful, otherwise return 0.
INFO: This function is used to remove repeated tokens, terms from each document's tokens.
*/
_Bool remove_repeated_term_token_1 (string *** doc_tokens, unsigned int * n_docs, unsigned int * n_tokens_per_doc) {
    if (doc_tokens != NULL && n_docs != NULL && n_tokens_per_doc != NULL) { //Check if the passed arguments are passed correctly.
        if ((*doc_tokens) != NULL && (*n_docs) != 0 && (*n_tokens_per_doc) != 0) { //Check if the passed arguments points and holds the correct info and data.
            for (unsigned int counter = 0; counter < (*n_docs); ++counter) { //For each document.
                unsigned int real_size = n_tokens_per_doc [counter]; //Hold the number of tokens in that document.

                for (unsigned int token = 0; token < n_tokens_per_doc [counter]; token++) { //For each token in the document
                    if ((*doc_tokens) [counter][token] == NULL) //If the token is equal to NULL, then skip
                        continue;

                    //Otherwise loop through each token again to see if the token is repeated or not and remove it.
                    for (unsigned int repeated = 0; repeated < (n_tokens_per_doc [counter] - 1); ++repeated)
                        if (token != repeated) //If pointers are not the same.
                            if ((*doc_tokens) [counter][repeated] != NULL) //If the string is not null.
                                if (compare_string (&((*doc_tokens) [counter][token]), (*doc_tokens) [counter][repeated])) { //Compare strings, if 1, then that means the token is repeated.
                                    free ((*doc_tokens) [counter][repeated]); //Free the repeated token
                                    (*doc_tokens) [counter][repeated] = NULL;
                                    --real_size; //Decrease the size by 1.
                                }
                }

                if (real_size != n_tokens_per_doc [counter]) {
                    string * new_list = NULL; //Create the new list which hold the organized list.
                    do {new_list = (string *) malloc (sizeof (string) * real_size);} while (new_list == NULL); //Allocate space for it.

                    //Reset the real_size to 0 in order to fill the new_list.
                    real_size = 0;
                    for (unsigned int inside = 0; inside < n_tokens_per_doc [counter]; ++inside) { //For each token in the document.
                        if ((*doc_tokens) [counter][inside] != NULL) { //Check if the token does not equal to null.
                            new_list [real_size++] = give_me_str_copy (&((*doc_tokens) [counter][inside])); //Make new copy of the token.
                            free ((*doc_tokens) [counter][inside]); //Free the already allocated token in the old token.
                            (*doc_tokens) [counter][inside] = NULL;
                        }
                    }

                    free ((*doc_tokens) [counter]); //Free old list.
                    (*doc_tokens) [counter] = NULL;

                    (*doc_tokens) [counter] = new_list; //Assign the new list to document list.
                    new_list = NULL;

                    n_tokens_per_doc [counter] = real_size; //Assign the new size of the list.
                }
            }

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to 3d array of strings, a pointer to an unsigned int which hold the number of documents, an array of unsigned int which hold the number of tokens in each document
     and a pointer to an unsigned int which hold the lenght of the largest token.

OUTPUT: Return 1 if printing is successful, otherwise return 0.
INFO: This function is used to print the tokens in each document in table format.
*/
_Bool print_doc_tokens (string *** doc_tokens, unsigned int * n_docs, unsigned int * n_tokens_per_doc, unsigned int * largest_token) {
    if (doc_tokens != NULL && n_docs != NULL && n_tokens_per_doc != NULL && largest_token != NULL) { //Check that the passed arguments are passed correctly.
        if ((*doc_tokens) != NULL && (*n_docs) != 0 && (*n_tokens_per_doc) != 0 && (*largest_token) != 0) { //Checks that the passed argumets points and holds the right data
            for (unsigned int counter = 0; counter < (*n_docs); ++counter) { //For each document
                if (counter == 0)
                    print_tokens (&((*doc_tokens) [counter]), &n_tokens_per_doc [counter], largest_token, &counter, 1); //Call the print_tokens function with headers
                else
                    print_tokens (&((*doc_tokens) [counter]), &n_tokens_per_doc [counter], largest_token, &counter, 0); //Call the print_tokens function with no headers
            }

            //This var will be allocated if the largest_token is less than 5
            unsigned int * temp = NULL;
            if ((*largest_token) < 5) { //Checks if the largest_token is less than 5
                do {temp = (unsigned int *) malloc (sizeof (unsigned int));} while (temp == NULL); //Allocate space for the temp
                (*temp) = (*largest_token); //Let the temp hold the largest_token value
                (*largest_token) = 5; //Change the largest_token value to 5
            }

            //Print |______________________|_________________________|
            printf ("\t|");
            for (unsigned int counter = 0; counter < ((*largest_token) + 4); printf ("_"), ++counter);
            printf ("|");
            for (unsigned char counter = 0; counter < 18; printf ("_"), ++counter);
            printf ("|\n");

            //Checks if the temp was allocated
            if (temp != NULL) {
                (*largest_token) = (*temp); //Set largest_token to its original value.
                free (temp); //Free temp
                temp = NULL;
            }

            return 1; //Return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to 2d array of strings, a pointer to the number of tokens, a pointert to the length of the largest token and a pointer to index of the document we print.
OUTPUT: Return 1 if the printing is correct, otherwise return 0.
INFO: This function is used to print token in a table form. If the index is passed as NULL, then the DocID column will not be printed, otherwise we will print it.
*/
_Bool print_tokens (string ** tokens, unsigned int * n_tokens, unsigned int * largest_token, unsigned int * index, _Bool inc_header) {
    if (tokens != NULL && n_tokens != NULL && largest_token != NULL) { //Checks if the passed arguments is passed correctly.
        if ((*tokens) != NULL && (*n_tokens) != 0 && (*largest_token) != 0) { //Checks if the passed argument points and holds the correct data.
            unsigned int * temp = NULL; //A var which will hold the value of largest_token if the largest_token is less than 5.
            if ((*largest_token) < 5) { //Check if the largest_token is less than 5
                do {temp = (unsigned int *) malloc (sizeof (unsigned int));} while (temp == NULL); //Allocate space of temp
                (*temp) = (*largest_token); //Let temp hold value of largest_token
                (*largest_token) = 5; //let the largest_token have value of 5
            }

            unsigned int diff = 0; //A var which will hold the difference beteween the largest_token + 2 and a token.

            if (index) { //Checks if the user want to print Doc ID column
                if (inc_header) { //Checks if the user want to build a header
                    printf ("\t ");
                    for (unsigned int counter = 0; counter < ((*largest_token) + 2 + 16 + 5); printf ("_"), ++counter);
                    printf ("\n");

                    print_token_empty_line (largest_token, 1);

                    printf ("\t| ");
                    diff = (((*largest_token) + 2) - 5);
                    
                    diff /= 2;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 1);
                    printf ("Token");
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);

                    if ((((*largest_token) + 2) - 5) % 2 != 0)
                        diff = (((((*largest_token) + 2) - 5) / 2) + 1);
                    
                    padding (&diff);
                    printf (" | ");
                    diff = 5;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 2);
                    printf ("Doc ID");
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                    padding (&diff);
                    printf (" |\n");

                    print_token_dashed_line (largest_token, 1);
                    print_token_empty_line (largest_token, 1);
                }

                //For each token format it in a table format.
                for (unsigned int counter = 0; counter < (*n_tokens); ++counter) {
                    printf ("\t| ");
                    diff = ((*largest_token) + 2) - str_len (&((*tokens) [counter]));
                    diff /= 2;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 3);
                    printf ("%s", (*tokens) [counter]);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                    if ((((*largest_token) + 2) - str_len (&((*tokens) [counter]))) % 2 != 0)
                        diff = (((((*largest_token) + 2) - str_len (&((*tokens) [counter]))) / 2) + 1);
                    padding (&diff);
                    printf (" | ");
                    diff = 16 - n_digits ((*index) + 1);
                    diff /= 2;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 4);
                    printf ("%u", ((*index) + 1));
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                    if ((16 - n_digits ((*index) + 1)) % 2 != 0)
                        diff++;
                    padding (&diff);
                    printf (" |\n");
                    print_token_dashed_line (largest_token, 1);
                    print_token_empty_line (largest_token, 1);
                }
            } else { //Means we will not print the Doc ID Column
                if (inc_header) { //Checks if the user will wants to print the header.
                    printf ("\t ");
                    for (unsigned int counter = 0; counter < ((*largest_token) + 4); printf ("_"), ++counter);
                    printf ("\n");

                    print_token_empty_line (largest_token, 0);

                    printf ("\t| ");
                    diff = (((*largest_token) + 2) - 5);
                    if (diff == 1)
                        ++diff;

                    diff /= 2;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 1);
                    printf ("Token");
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);

                    if ((((*largest_token) + 2) - 5) % 2 != 0)
                        diff = (((((*largest_token) + 2) - 5) / 2) + 1);
                        
                    padding (&diff);
                    printf (" |\n");

                    print_token_dashed_line (largest_token, 0);
                    print_token_empty_line (largest_token, 0);
                }

                //For each token format it in a table form
                for (unsigned int counter = 0; counter < (*n_tokens); ++counter) {
                    printf ("\t| ");
                    diff = ((*largest_token) + 2) - str_len (&((*tokens) [counter]));
                    diff /= 2;
                    padding (&diff);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 3);
                    printf ("%s", (*tokens) [counter]);
                    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), 7);
                    if ((((*largest_token) + 2) - str_len (&((*tokens) [counter]))) % 2 != 0)
                        diff = (((((*largest_token) + 2) - str_len (&((*tokens) [counter]))) / 2) + 1);
                    padding (&diff);
                    printf (" |\n");
                    print_token_dashed_line (largest_token, 0);    
                    print_token_empty_line (largest_token, 0);
                }

                printf ("\t|");
                for (unsigned int counter = 0; counter < ((*largest_token) + 4); printf ("_"), ++counter);
                printf ("|\n");
            }

            //Checks if the temp is allocates
            if (temp != NULL) {
                (*largest_token) = (*temp); //Let largest_token contains the old value stored in temp
                free (temp); //Deallocate the temp var
                temp = NULL;
            }

            return 1;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a string and a pointer to a strnig
OUTPUT: Return 0 if one is bigger than two, 1 if the two is bigger than one and -1 if there is an error.
INFO: This function is used to check which of these strings are bigger.
*/
char which_is_bigger (string * one, string * two) {
    if (one != NULL && two != NULL) { //checks that arguments are passed correctly.
        if ((*one) != NULL && (*two) != NULL) { //Checks that the arguments points to the correct things.
            unsigned int one_size = str_len (one); //Get the size of the one
            unsigned int two_size = str_len (two); //Get the size of the two

            if (one_size > 0 && two_size > 0) { //Check if the user did not pass an empty string.
                if (one_size < two_size) { //Check if the string one contain less characters than string two
                    for (unsigned int counter = 0; counter < one_size; ++counter) { //iterate until the end of the string one
                        if ((*one) [counter] > (*two) [counter])
                            return 0;
                        else if ((*one) [counter] < (*two) [counter])
                            return 1;
                    }

                    return 1; //Means That the string two is bigger.
                } else if (one_size > two_size) { //Check of string one contains more characters than string two
                    for (unsigned int counter = 0; counter < two_size; ++counter) { //iterate until the end of the string two
                        if ((*one) [counter] > (*two) [counter])
                            return 0;
                        else if ((*one) [counter] < (*two) [counter])
                            return 1;
                    }

                    return 0; //Means the string one is bigger
                } else { //Means the user passed 2 strings with the same length.
                    for (unsigned int counter = 0; counter < one_size; ++counter)
                        if ((*one) [counter] > (*two) [counter])
                            return 0;
                        else if ((*one) [counter] < (*two) [counter])
                            return 1;

                    return -1; //Means that the user passed an equal strings.
                }

                return -1; //Means that the user passed the same string twice.
            } else
                return -1;
        } else
            return -1;
    } else
        return -1;
}


/*
INPUT: an unsigned int value holding a number
OUTPUT: return an unsigned int holding the number of digits.
INFO: This function is used to get the number of digits of a number of type unsigned int.
*/
unsigned int n_digits (unsigned int number) {
    if (number == 0) return 1; //Checks if the number was 0, then return 1
    else { //Meaning the user did not send a 0.
        unsigned int n = 0; //Hold the number of digits
        while (number != 0) { //Loops until the number reaches zero
            number /= 10; //Divid the number by 10 and store in the number var
            ++n; //Increment n by 1
        }

        return n; //return the output.
    }
}


/*
INPUT: A void pointer as we expect either [string ** or string *], a pointer to an unsigned int which hold how many docs, and an array which tells us how many tokens per doc.
OUTPUT: Return a non zero value if everything is done correctly, otherwise return 0.
INFO: This function is used to get the length of the largest token or term from document's tokens or list of tokens/term.
*/
unsigned int largest_token_term (void * tokens_doct, unsigned int * n_docs_toks, unsigned int * n_tokens_per_doc) {
    if (tokens_doct != NULL && n_docs_toks != NULL) { //Check if the passed arguments are passed correctly.
        if ((*n_docs_toks) != 0) { //Checks if the value is not equal to zero.
            unsigned int largest_length = 0; //Set the return value to zero.

            if (n_tokens_per_doc != NULL) { //Checks if the passed argument of void * is of deal with as string ** or string *
                if ((*n_tokens_per_doc) != 0) { //Make sure that the user did not passed zero as in the first thing.
                    string ** docs = ((string **) tokens_doct); //Do type casting

                    //For each doc loop through its tokens and get the largest length and assign it to the return result.
                    for (unsigned int counter = 0; counter < (*n_docs_toks); ++counter)
                        for (unsigned int inside = 0; inside < n_tokens_per_doc [counter]; ++inside)
                            if (str_len (&docs [counter][inside]) > largest_length)
                                largest_length = str_len (&docs [counter][inside]);
                } else
                    return 0;
            } else { //Means the user have passed string *
                string * tokens = ((string *) tokens_doct);

                //For each token get it length if it is bigger assign it to the return value.
                for (unsigned int counter = 0; counter < (*n_docs_toks); ++counter)
                    if (str_len (&tokens [counter]) > largest_length)
                        largest_length = str_len (&tokens [counter]);
            }

            return largest_length;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A 2d Array of string which holds file names, A pointer to 3d dimension array which holds the data from files either Query_Document_INFO, an unsigned int which
        tells me how many files we going to read, and a pointer to a 1d array of unsigned interger which hold the size of each document [Number of lines].

OUTPUT: Returns unsigned int value representing how many files have been read from the original input from n_files variable.

INFO: This function is used to read from multiiple files.
*/
unsigned int get_input_from_files (string * file_names, string *** documents_query, unsigned int n_files, unsigned int ** document_query_size) {
    if (file_names != NULL && documents_query != NULL && n_files != 0 && document_query_size != NULL) { //Checks is the arguments sent are the right values.
        if ((*file_names) != NULL && (*documents_query) == NULL && (*document_query_size) == NULL) { //Check if the we deference any pointers, its value is equal to NULL
            unsigned int real_size = 0; //Hold the real size of the documents that will be read.

            do {(*documents_query) = (string **) malloc (sizeof (string *) * n_files);} while ((*documents_query) == NULL); //Allocate space for the documents
            for (unsigned int counter = 0; counter < n_files; (*documents_query) [counter] = NULL, ++counter); //Make every document have initial value of NULL.

            do {(*document_query_size) = (unsigned int *) calloc (n_files, sizeof (unsigned int));} while ((*document_query_size) == NULL); //Allocate space for document size and have initial value of 0.

            //For each file go check if the name does not equal to NULL, then call get_input_from_file function.
            //If the return is 1, the reading from file was successful, otherwise it is a failure.
            for (unsigned int counter = 0; counter < n_files; ++counter)
                if (file_names [counter] != NULL)
                    if (get_input_from_file (file_names [counter], &(*documents_query) [real_size], &(*document_query_size) [real_size]))
                        real_size++;
                 
            
            if (real_size >= 1 && real_size < n_files) {
                //Reallocate the documents to the right size.
                void * reallocation = NULL;
                do {reallocation = realloc ((*documents_query), sizeof (string **) * real_size);} while (reallocation == NULL);

                if (reallocation != (*documents_query))
                    (*documents_query) = (string **) reallocation;

                reallocation = NULL;

                //Reallocate the document size ot the right size.
                do {reallocation = realloc ((*document_query_size), sizeof (unsigned int) * real_size);} while (reallocation == NULL);
                
                if (reallocation != (*document_query_size))
                    (*document_query_size) = (unsigned int *) reallocation;
            
                reallocation = NULL;
                
            } else if (real_size == 0) { //If real_size is equal to zero, then deallocate the allocated places for: documents and document size.
                free ((*documents_query));
                (*documents_query) = NULL;
                free ((*document_query_size));
                (*document_query_size) = NULL;
            }

            return real_size;
        } else
            return 0;
    } else
        return 0;
}


/*
INPUT: A pointer to a 2d array and a char type which indicates what type of algorithm [1:Incidence, 2:Inverted, 3:Positional].
OUTPUT: Return an array of  integer which hold the result of the or query Or NULL otherwise.
INFO: This function perform an or operation on the queries.
*/
unsigned int * perform_or_operation (unsigned int *** queries, char algo_type) {
    if (queries != NULL && algo_type != 0) {
        if ((*queries) != NULL) {
            unsigned int * return_query = NULL; //The result of the OR operation.

            if (algo_type == 1) { //Means we do oring operation on Incidence_matrix.
                do {return_query = (unsigned int *) malloc (sizeof (unsigned int) * ((*queries) [0][0] + 1));} while (return_query == NULL); //Allocate Space For the Return Result Of The Oring Operation.
                return_query [0] = (*queries) [0][0]; // The first index hold the size of the array.
                //For each index in the first query or it with the second query and store it in the result.
                for (unsigned int counter = 1; counter <= (*queries) [0][0]; return_query [counter] = ((*queries) [0][counter] | (*queries) [1][counter]), ++counter);
            } else if (algo_type == 2) { //Means we do oring operation on Inverted_Index.
                unsigned int index_1 = 1; //Points at the first index of the first query.
                unsigned int index_2 = 1; //Points at the first index of the second query.
                unsigned int real_size = 1; //Hold the real size of return result.

                do {return_query = (unsigned int *) malloc (sizeof (unsigned int) * ((*queries) [0][0] + (*queries) [1][0] + 1));} while (return_query == NULL); //Allocate space for return space.

                //Loop until at least one of the index reach the size of one of the other query
                while (index_1 <= (*queries) [0][0] && index_2 <= (*queries) [1][0]) {
                    if ((*queries) [0][index_1] < (*queries) [1][index_2]) { //Check if the first query contains lower value than second query.
                        return_query [real_size] = (*queries) [0][index_1]; //Assign the value of the first query in the return query.
                        ++index_1; //Increment the index 1
                    } else if ((*queries) [0][index_1] == (*queries) [1][index_2]) { //Check if the both query are containing the same value.
                        return_query [real_size] = (*queries) [1][index_2];

                        //Increment both indices.
                        ++index_2;
                        ++index_1; 
                    } else { //Means that the second query holds the small value and then increment the its index.
                        return_query [real_size] = (*queries) [1][index_2];
                        ++index_2;
                    }

                    ++real_size; //Increment the real size by 1;
                }

                if (index_1 == ((*queries) [0][0] + 1)) //Check if the index of the query is equal to first query size
                    for (; index_2 <= (*queries) [1][0]; return_query [real_size] = (*queries) [1][index_2], ++index_2, ++real_size); //Assign the rest of the second query to the result query.
                else
                    for (; index_1 <= (*queries) [0][0]; return_query [real_size] = (*queries) [0][index_1], ++index_1, ++real_size); //Assign the rest of the first query to the result query.

                return_query [0] = (real_size - 1); //Hold the real size;
            } else
                return NULL;

            return return_query; //Return the result of the oring.
        } else
            return NULL;
    } else
        return NULL;
}


/*
INPUT: A pointer to a 2d array and a char type which indicates what type of algorithm [1:Incidence, 2:Inverted, 3:Positional].
OUTPUT: Return an array of unsigned integer which hold the result of the or query Or NULL otherwise.
INFO: This function is used to perform AND operation in the query given.
*/
unsigned int * perform_and_operation (unsigned int *** queries, unsigned char k, char algo_type) {
    if (queries != NULL && algo_type != 0) {
        if ((*queries) != NULL) {
            unsigned int * result_query = NULL;

            if (algo_type == 1) { //Means we do ANDING operation to the Incidence_Matrix Algo.
                do {result_query = (unsigned int *) malloc (sizeof (unsigned int) * ((*queries) [0][0] + 1));} while (result_query == NULL); //Alloacte space of result query.
                result_query [0] = (*queries) [0][0];
                for (unsigned int counter = 1; counter <= (*queries) [0][0]; result_query [counter] = (*queries) [0][counter] & (*queries) [1][counter], ++counter);
            } else if (algo_type == 2) { //Means we do ANDING operation to the Inverted_Index Algo.
                unsigned int index_1 = 1; //Points to the first query array.
                unsigned int index_2 = 1; //Points to the second query array.
                unsigned int real_size = 1; //Hold the real size of the return result.
                
                do {result_query = (unsigned int *) malloc (sizeof (unsigned int) * ((*queries) [0][0] + (*queries) [1][0] + 1));} while (result_query == NULL); //Allocate the result query with the maximum size.

                while (index_1 <= (*queries) [0][0] && index_2 <= (*queries) [1][0]) {  //Until we reach the end one of the list
                    if ((*queries) [0][index_1] == (*queries) [1][index_2]) {
                        result_query [real_size] = (*queries) [0][index_1];
                        index_1++;
                        index_2++;
                        real_size++;
                    } else if ((*queries) [0][index_1] < (*queries) [1][index_2]) {
                        ++index_1;
                    } else {
                        ++index_2;
                    }
                }

                if (real_size != 1) {
                    void * reallocation = NULL;
                    do {reallocation = realloc (result_query, (sizeof (unsigned int) * real_size));} while (reallocation == NULL);

                    if (reallocation != result_query)
                        result_query = (unsigned int *) reallocation;

                    reallocation = NULL;
                    result_query [0] = (real_size - 1);
                } else {
                    free (result_query);
                    result_query = NULL;
                }
            } else if (algo_type == 3) { //Means We do ANDING operation to the Positional_Index Algo.
                if (k != 0) {
                    unsigned int index_1 = 1, index_2 = 1, real_size = 1;
                    unsigned int * _return_ = NULL;
                    do {_return_ = (unsigned int *) malloc (sizeof (unsigned int) * ((*queries) [0][0] + (*queries) [1][0] + 1));} while (_return_ == NULL);

                    while (index_1 <= (*queries) [0][0] && index_2 <= (*queries) [1][0]) {
                        int diff = ((*queries) [1][index_2] - (*queries) [0][index_1]);
                        if (diff < 0)
                            diff *= -1;

                        if (diff <= k) {
                            _return_ [real_size++] = (*queries) [1][index_2];
                            index_2++;
                            index_1++;
                        } else {
                            if ((*queries) [0][index_1] < (*queries) [1][index_2]) {
                                index_1++;
                            } else if ((*queries) [1][index_2] < (*queries) [0][index_1]) {
                                index_2++;
                            } else {
                                index_1++;
                                index_2++;
                            }
                        }
                    }

                    if (real_size != 1) {
                        void * reallocation = NULL;
                        do {reallocation = realloc (_return_, sizeof (unsigned int) * real_size);} while (reallocation == NULL);
                        if (reallocation != _return_)
                            _return_ = (unsigned int *) reallocation;
                        
                        reallocation = NULL;
                        
                        _return_ [0] = (real_size - 1);
                    } else {
                        free (_return_);
                        _return_ = NULL;
                    }

                    return _return_;
                } else
                    return NULL;
            } else
                return NULL;

            return result_query;
        } else
            return NULL;
    } else
        return NULL;
}


/*
INPUT: A pointer to a 1d array and a char type which indicates what type of algorithm [1:Incidence, 2:Inverted, 3:Positional].
OUTPUT: Return an array of unsigned integer which hold the result of the or query Or NULL otherwise.
INFO: This function is used to perform NOT operation in the query given.
*/
unsigned int * perform_not_operation (unsigned int ** query, unsigned int n_docs, char algo_type) {
    if (query != NULL && algo_type != 0) {
        if ((*query) != NULL) {
            unsigned int * result_query = NULL; //Hold the retsult of not operation of the query

            if (algo_type == 1) { //Means we do NOT operation to Incidence_Matrix algo.
                do {result_query = (unsigned int *) malloc (sizeof (unsigned int) * ((*query) [0] + 1));} while (result_query == NULL); //Allocate space for the result query.
                result_query [0] = (*query) [0]; //Set the size of the result query.
                for (unsigned int counter = 1; counter <= (*query) [0]; ++counter) { //invert each one to zero and each zero to one.
                    if ((*query) [counter] == 1)
                        result_query [counter] = 0;
                    else
                        result_query [counter] = 1;
                }
            } else if (algo_type == 2) { //Means we do NOT operation to Inverted_Index algo.
                if (n_docs > 0 && n_docs > (*query) [0]) { //Check if the size of number of documents is greater than zero and greater than the size of the query.
                    if ((n_docs - (*query) [0]) >= 1) { //Checks if the difference between sizes greater than or equal 1.
                        do {result_query = (unsigned int *) malloc (sizeof (unsigned int) * (n_docs - (*query) [0] + 1));} while (result_query == NULL); //Allocate space for the result query.
                        unsigned int index = 1; //Hold the index of the size of result query.
                        _Bool already_exists = 0; //Tells me if the docID already exist in the array we passed.
                        for (unsigned int counter = 1; counter <= n_docs; ++counter) { //Loop until the n_docs.
                            for (unsigned int inside_counter = 1; inside_counter <= (*query) [0]; ++inside_counter) //For each docID loop through the docIDs we have.
                                if (counter == (*query) [inside_counter]) { //If the docID already exist
                                    already_exists = 1; //Set already_exist to 1 and break
                                    break;
                                }
                            
                            if (already_exists) //If already_exist is 1 reset it to 0 to prepare for the next checking on the docID.
                                already_exists = 0;
                            else { //Else put that docID in the result_query.
                                result_query [index++] = counter;
                            }

                        }

                        result_query [0] = n_docs - (*query) [0]; //Put the size of the return result on the first index of the array.
                    } else
                        return NULL;
                } else
                    return NULL;
            } else
                return NULL;
            
            return result_query;
        } else
            return NULL;
    } else
        return NULL;
}


/*
INPUT: A stream type, and size_t size which hold the starter size of the string.
OUTPUT: Return a string if the user an input, otherwise return NULL, if the the user entered nothing.
INFO: This function is used to check the input the of the user and make the right size of the string.
*/
string check_input (FILE * stream, size_t starter_size) {
    if (stream != NULL && starter_size != 0) {
        int char_input = 0; //Hold the character value from the keyboard.
        size_t input_len = 0; //Hold the correct size of the string.

        string input = NULL; //Allocated place to store the input of the user
        do {input = (string) malloc (sizeof (char) * starter_size);} while (input == NULL);

        while ((char_input = fgetc (stream)) != EOF && char_input != 10) { //Get data from the user until the user press enter or entered EOF value.
            input [input_len++] = (char) char_input; //Assign the character the user entered to the string holder.
            if (input_len == starter_size) { //Check if the input length reached the starter size.
                void * reallocation = NULL; //Reallocated the existing string to hold more space and store the result in another variable
                do {reallocation = realloc (input, sizeof (char) * (starter_size + starter_size));} while (reallocation == NULL);

                if (input != reallocation)
                    input = (string) reallocation;

                reallocation = NULL;
                starter_size += starter_size; //Increase the cycle by itslef.
            }
        }

        input [input_len++] = '\0'; //Put the string terminator
        if (input_len == 1 && input [(input_len - 1)] == '\0') { //Means the user pressed enter as the first character an nothing is else.
            free (input);
            input = NULL;
            return NULL;
        } else {

            //Allocate the exact size of the string and get rid of the extra space, the same steps in the while loop.
            void * reallocation = NULL;
            do {reallocation = realloc (input, sizeof (char) * input_len);} while (reallocation == NULL);

            if (input != reallocation) //Reallocation is done in a new space.
                input = (string) reallocation;
            
            reallocation = NULL;

            return input;
        }
    } else
        return NULL;
}


/*
INPUT: A pointer to 3d array of string, an array which hold meta data about the 3d array.
OUTPUT: Return an array of string, otherwise return NULL.
INFO: This function is used to convert the 3d to 2d.
*/
string * degrade_list_2 (string *** new_list, unsigned int * meta) {
    if (new_list != NULL && meta != NULL) {
        if ((*new_list) != NULL && (*meta) != 0) {
            string * tokens = NULL; //The 2d list
            do {tokens = (string *) malloc (sizeof (string) * meta [0]);} while (tokens == NULL); //Allocate space for it.

            meta [0] = 0; //Set the first value of meta to zero.
            //For each document loop through its tokens and assign each token to the new array.
            for (unsigned int counter = 0; counter < meta [1]; counter++) 
                for (unsigned int inside = 0; inside < meta [(2 + counter)]; ++inside)
                    tokens [meta [0]++] = give_me_str_copy (&(*new_list) [counter][inside]);

            return tokens;
        } else
            return NULL;
    } else
        return NULL;
}